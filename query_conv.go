package urlvector

const (
	hex = "\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x00\x01\x02\x03\x04\x05\x06\a\b\t\x10\x10\x10\x10\x10\x10\x10\n\v\f\r\x0e\x0f\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\n\v\f\r\x0e\x0f\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10"
	// Hex digits in upper case.
	hexUp = "0123456789ABCDEF"
)

// Unescape byte array using itself as a destination.
func unescape(p []byte) []byte {
	l := len(p)
	n := len(p)
	if l < 3 {
		return p
	}
	_ = p[l-1]
	for i := 0; i < n; i++ {
		switch p[i] {
		case '%':
			if i+2 < l {
				x2 := hex[p[i+2]]
				x1 := hex[p[i+1]]
				if x1 != 16 || x2 != 16 {
					p[i] = x1<<4 | x2
					copy(p[i+1:], p[i+3:])
					n -= 2
				}
			}
		case '+':
			p[i] = ' '
		}
	}
	return p[:n]
}

func escape(vec *Vector, p []byte) []byte {
	l := len(p)
	if l == 0 {
		return p
	}
	o := vec.BufLen()
	_ = p[l-1]
	for i := 0; i < l; i++ {
		if p[i] >= 'a' && p[i] <= 'z' || p[i] >= 'A' && p[i] <= 'Z' ||
			p[i] >= '0' && p[i] <= '9' || p[i] == '-' || p[i] == '.' || p[i] == '_' {
			vec.BufAppendByte(p[i])
		} else if p[i] == ' ' {
			vec.BufAppendByte('+')
		} else {
			vec.BufAppendByte('%')
			vec.BufAppendByte(hexUp[p[i]>>4])
			vec.BufAppendByte(hexUp[p[i]&15])
		}
	}
	return vec.Buf()[o:]
}
